input {
	http {
		port => 8080
		codec => protobuf {
			class_name => "Export::Bt::BusinessTransactions"
			include_path => ['/opt/logstash-5.5.2/etc/dt_bt_export-6.3.5.rb']
		}
		tags => "stage1"
		threads => 4
	}
	http {
		port => 8081
		codec => "json"
		tags => "stage2"
		threads => 16
	}
}
filter {
	mutate {
		remove_field => [ "headers", "host"  ]
	}

    	if !("splitted_bts" in [tags] and [businessTransactions]) {
        	json {
            		source => "message"
        	}
        	split {
            		field => "businessTransactions"
            		add_tag => ["splitted_bts"]
        	}
    	}

    	if ( "splitted_bts" in [tags] and [businessTransactions][occurrences]) {
        	split {
            		field => "[businessTransactions][occurrences]"
        	}
    	}
	if ("stage2" in [tags] ) {
		mutate {
			remove_tag => [ "stage1", "splitted_bts" ]
			add_tag => [ "application", "serverName", "systemProfile" ]
		}

		# BusinessTransaction type=1 (Page Action BT)
                # if the BusinessTransaction is a Visit BT there is no Responsetime, we remove the field again
                #  
		if ( [businessTransactions][type] == 1 ) {
			mutate {
				add_field => {
					"clientTime" => '%{[businessTransactions][occurrences][clientTime]}'
                			"serverTime" => '%{[businessTransactions][occurrences][serverTime]}'
					#"apdex" => "%{[businessTransactions][occurrences][apdex]}"
				}
			}
		}
		mutate {
			add_field => {
				"tagging_names" => "%{[businessTransactions][dimensionNames]}"
			}                                
			#merge => { "tagging_names" => "application" }
		}
		mutate {
			add_field => {
				"tagging_values" => "%{[businessTransactions][occurrences][dimensions]}"
				"application" => "%{[businessTransactions][application]}"
                       		"businesstransaction" => "%{[businessTransactions][name]}"
				"systemProfile" => "%{[businessTransactions][systemProfile]}"
				"project" => "%{[businessTransactions][systemProfile]}"
				"responseTime" => "%{[businessTransactions][occurrences][responseTime]}"
				"time" => "%{[businessTransactions][occurrences][startTime]}"
				"resultmeasure_names" => "%{[businessTransactions][measureNames]}"
				"resultmeasure_values" => "%{[businessTransactions][occurrences][values]}"
			}
		}
	
		# BusinessTransaction type=2 (Visit BT)
		# if the BusinessTransaction is a Visit BT there is no Responsetime, we remove the field again
		# 
		if ( [businessTransactions][type] == 2 ) {
			mutate {
				remove_field => [ "responseTime" ]
				add_field => { 
					"clientIP" => "%{[businessTransactions][occurrences][clientIP]}"
					"clientFamily" => "%{[businessTransactions][occurrences][clientFamily]}"
					"continent" => "%{[businessTransactions][occurrences][continent]}"
					"country" => "%{[businessTransactions][occurrences][country]}"
					"city" => "%{[businessTransactions][occurrences][city]}"
					"failedActions" => "%{[businessTransactions][occurrences][failedActions]}"
					"clientErrors" => "%{[businessTransactions][occurrences][clientErrors]}"
					"osFamily" => "%{[businessTransactions][occurrences][osFamily]}"
					"osName" => "%{[businessTransactions][occurrences][osName]}"
					"apdex" => "%{[businessTransactions][occurrences][apdex]}"
					"converted" => "%{[businessTransactions][occurrences][converted]}"					
				}
				add_tag => [ "clientIP", "clientFamily", "continent", "country", "city", "osFamily", "osName", "converted"]
			}
			geoip {
      				source => "clientIP"
     				target => "geoip"
      				database => "/opt/logstash-5.5.2/etc/GeoLite2-City.mmdb"
				fields => [ "continent_code","country_code2", "latitude", "longitude" ]
      				add_tag => [ "continent_code", "country_code2", "geohash" ]
      				add_field => { 
					"continent_code" => "%{[geoip][continent_code]}"
					"country_code2" => "%{[geoip][country_code2]}"
					"geohash" => "none"
					"location" => [ "%{[geoip][longitude]}", "%{[geoip][latitude]}" ]
				}
    			}
			#if ( "%{[geoip][city_name]}" == [city_name] ) {
			#	mutate {
			#		replace => { "city" => "N/A" }
			#	}
			#}
			#
			# calculating our own geohash code for mapping on grafana's worldmap
			#
			ruby {
				code => "
					def encode(latitude, longitude, precision=12)
    						latlng = [latitude, longitude]
    						points = [[-90.0, 90.0], [-180.0, 180.0]]
    						is_lng = 1
    						(0...precision).map {
      							ch = 0
      							5.times do |bit|
        							mid = (points[is_lng][0] + points[is_lng][1]) / 2
        							points[is_lng][latlng[is_lng] > mid ? 0 : 1] = mid
        							ch |=  [0x10, 0x08, 0x04, 0x02, 0x01][bit] if latlng[is_lng] > mid
        							is_lng ^= 1
      							end
      							'0123456789bcdefghjkmnpqrstuvwxyz'[ch,1]
    						}.join
  					end

					event['geohash'] = ('%s' % encode(event['[geoip][latitude]'].to_f,event['[geoip][longitude]'].to_f,5))
				"
			}	
		}
		ruby {
        		code => "
				event['project'] = ('%s_dyn' % event['project'].split('_')[0].downcase)
            			resultmeasures = event['resultmeasure_names'].split(',')
				resultvalues = event['resultmeasure_values'].split(',')
				$i = 0
            			for measure in resultmeasures
					measure.gsub! ' ', '_'
                			measure.gsub! '(', ''
					measure.gsub! ')', ''
					event[measure] = ('%.3f' % resultvalues[$i]).to_f
					$i +=1
            			end

				taggingvalues = event['tagging_values'].split(',')
				taggingnames = event['tagging_names'].split(',')
				$i = 0
				for tag in taggingnames
					tag.gsub! ' ', '_'
					tag.gsub! '(', ''
					tag.gsub! ')', ''
					event[tag] = taggingvalues[$i]
					(event['tags'] ||= []) << tag
					#event[sprintf('split_name_%d',$i)] = tag
					#event[sprintf('split_value_%d',$i)] = taggingvalues[$i]
					$i +=1
				end
        		"
    		}
		date {
			match => [ "[businessTransactions][occurrences][startTime]", "UNIX_MS" ]
		}
		mutate {
			remove_field => [ "businessTransactions","resultmeasure_names","resultmeasure_values", "tagging_names", "tagging_values" , "@version", "sequence", "message", "type", "geoip"]
			remove_tag => [ "stage2" ]
		}
	}
}

output {
	if [businessTransactions] {
		http {
			http_method => "post"
			url => "http://localhost:8081"
		}
	}
	else {
		#file {
   		#	path => "/tmp/logstash.out"
 		#}
		#elasticsearch {
		#	hosts => ["127.0.0.1:9200"]
		#	index => "dtbtexp-%{+YYYY.MM.dd}"
		#	document_type => "bt"
		#	manage_template => "false"
		#	template_name => "dtbtexp"
		#}

		influxdb {
			host => "influxdb"
			# to use a database that uses the project code
			#db => "%{[project]}"
			db => "dynatrace"
			allow_time_override => true
			measurement => "%{[businesstransaction]}"
			exclude_fields => [ "businesstransaction", "@timestamp", "@version", "sequence", "message", "type", "project", "location"]
			use_event_fields_for_data_points => true
		}

	}
}
